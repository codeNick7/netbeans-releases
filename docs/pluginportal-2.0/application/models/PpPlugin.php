<?php

/**
 * PpPlugin
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class PpPlugin extends BasePpPlugin {

    private $_basePath = null;
    public $_moduleAuthor = null;
    public $_showInClient = null;
    public $_summary = null;
    public $_license = null;
    public $hard_dependency = 0;
    public $infoAsXml;
    public $log = array();

    public function setUp() {
        parent::setUp();
        $this->hasMany('PpNetbeansVersion as Versions', array(
            'local' => 'plugin_id',
            'foreign' => 'version_id',
            'refClass' => 'PpPluginToVersion'));
    }


    /*
     * return netbeans versions as array
     */

    public function getNetbeansVersionsAsArray() {
        $vers=array();
        if ($this->Binaries->count() > 0) {
            foreach ($this->Binaries as $b) {
                $vers[] = $b->version_id;
            }
        }
        //var_dump($this->Versions);
        return $vers;
    }

    public static function updateAverageRating($id) {
        $const = 3;
        // AvgNumOfRatingsForAll is the average number of ratings for all books shown (where RateCount > 0)
        $allVotes = Doctrine_Query::create()->select('count(id)')->from('PpRating')->fetchOne(null, Doctrine_Core::HYDRATE_SINGLE_SCALAR);
        $allPlugins = Doctrine_Query::create()->select('pluginid')->from('PpPlugin')->groupBy('publicid')->execute();
        $AvgNumOfRatingsForAll = $allVotes / $allPlugins->count();

        // AvgRatingForAll is the average unweighted rating for all books shown (where RateCount >
        $pl = Doctrine_Query::create()->select('plugin_pluginid, count(id) as c, sum(rating_level) as s')->from('PpRating')->groupBy('plugin_pluginid')->execute();
        $n = 0;
        $sumAvg = 0;
        foreach ($pl as $p) {
            $n+=$p->c;
            $sumAvg+=$p->s; // / $p->c;
        }
        $AvgRatingForAll = $sumAvg / $n;
        // now recalculate
        $pl = Doctrine_Query::create()->select('plugin_pluginid, count(id) as c, sum(rating_level) as s')
                        ->from('PpRating r')->where('plugin_pluginid=?', $id)->groupBy('plugin_pluginid')->execute();
        foreach ($pl as $p) {
            $bayessAvg = (($AvgNumOfRatingsForAll * $const * $AvgRatingForAll) + $p->s) / ($p->c + ($AvgNumOfRatingsForAll * $const));
            // check if plugin still exists
            $plug = Doctrine_Query::create()->from('PpPlugin')->where('pluginid=?', $p->plugin_pluginid)->fetchOne();
            if (!empty($plug)) {
                $plug->average_rating = round($bayessAvg, 3);
                $plug->save();
                Doctrine_Query::create()->update('PpPlugin p')->set('p.average_rating','?',$bayessAvg)->where('publicid=?',$plug->publicid)->execute();
            }
        }
    }

    /**
     *
     * @param string $pName Name of the module (without .nbm extension)
     * @param string $file Path to the file
     * @param string $tmpPath Tmp path where to unzip to
     * @param string $unzip Path to unzip executable
     * @return boolean True on success False on Err
     */
    public function unpackPluginAndLoadInfoXML($pName, $file, $tmpPath, $unzip) {
        $cmd = escapeshellcmd($unzip . ' ' . $file . ' -d ' . $tmpPath . $pName);
        exec($cmd, $out);
        //echo '<hr/><hr/>'.$cmd.'<br/>';
        if (file_exists($tmpPath . $pName . '/Info/info.xml')) {
            // parse teh info manifest
            @$xml = simplexml_load_file($tmpPath . $pName . '/Info/info.xml');
            // extract some value from that
            if ($xml) {
                $arr = (array) $xml->manifest;
                $arr = $arr['@attributes'];

                $this->home_page_url = (string) $xml->attributes()->homepage;
                $this->plugin_name = $arr['OpenIDE-Module-Name'];
                $this->summary = $arr['OpenIDE-Module-Short-Description'];
                $this->_summary = $arr['OpenIDE-Module-Short-Description'];
                $this->description = $arr['OpenIDE-Module-Long-Description'];
                $this->nbm_filename = $pName . '.nbm';
                $this->_moduleAuthor = (string) $xml->attributes()->moduleauthor;
                $this->_showInClient = $arr['AutoUpdate-Show-In-Client'];
                $this->_license = (string) $xml->license;
                if(!empty($arr['OpenIDE-Module-Module-Dependencies']) && preg_match('/20\d{10}/', $arr['OpenIDE-Module-Module-Dependencies'])) {
                    $this->hard_dependency=1;
                }
            }
            // check if it's signed
            $cmd = escapeshellcmd('ls ' . $tmpPath . $pName) . '/META-INF/  | egrep \'DS|SF|RS\'';
            //echo $cmd.'<br/>';
            exec($cmd, $res);

            if (count($res) > 1) {
                $this->signed = '1';
            } else {
                $this->signed='0';
            }
            // now delete unpacked module
            exec(escapeshellcmd('rm -rf ' . $tmpPath . $pName), $out);
            return true;
        } else {
            // missng manifest, bail out
            //PpLog::logMe(null, NbSsoUser::getInstance()->getUsername(), 'Plugin ' . $pName . ' is missing manifest or unzip not successfull:<br> ' . implode('<br>', $out));
            return false;
        }
    }

    public function unpackPluginPackAndVerifySignatures($pName, $file, $tmpPath, $unzip) {
        $cmd = $unzip . ' ' . $file . ' -d ' . $tmpPath . $pName;
        exec(escapeshellcmd($cmd), $out);
        //echo $cmd.'<hr/>';
        if (is_dir($tmpPath . $pName)) {
            $files = scandir($tmpPath . $pName);
            //$this->logme('archive extracted');
            if ($files) {
                $moduleCount = 0;
                $signedCount = 0;
                $requiredAttribErr = 0;
                $this->logme('');
                foreach ($files as $f) {
                    if (strstr($f, '.nbm')) {
                        $this->logme('submodule found: '.$f);
                        $moduleCount++;
                        //echo 'm: '.$f.'<br/>';
                        $p = new PpPlugin();
                        $p->unpackPluginAndLoadInfoXML(substr($f, 0, -4), $tmpPath . $pName . '/' . $f, $tmpPath . $pName . '/', $unzip);
                        if ($p->signed == 1) {
                            $signedCount++;
                        }
                        // check if submodule has necessary attributes if is to be shown in client
                        if (strtolower($p->_showInClient) == 'true') {
                            if (empty($p->_moduleAuthor) || empty($p->_summary)
                                    || empty($p->_license) || trim($p->_license) == "[NO LICENSE SPECIFIED]") {
                                $requiredAttribErr = 1;
                                $this->logme('&nbsp;&nbsp;|_ But is missing req attributes like Author, Summary, License!');
                            }
                        }
                        unset($p);
                    }
                }
            }
            exec(escapeshellcmd('rm -rf ' . $tmpPath . $pName));
        }
        if ($moduleCount == $signedCount) {
            $this->signed = '1';
            $this->logme('All submodules are signed - overall Signed');
        } else {
            $this->logme('Not all submodules are signed');
        }
        if (!$requiredAttribErr) {
            return true;
        } else {
            return false;
        }
    }


    /**
     * send notification email on comment event
     * @param PpComment $comment
     */
    public function sendNotificationMailOnComment($comment) {
        $subject = PpPreference::preference()->commentsubject;
        $subject = str_replace('${Plugin.plugin_name}', $this->plugin_name, $subject);
        $body = PpPreference::preference()->commentemailbody;
        $body = str_replace('${Plugin.plugin_name}', $this->plugin_name, $body);
        $body = str_replace('${Comment.title}', $comment->title, $body);
        $body = str_replace('${Comment.comment_summary}', $comment->comment_summary, $body);
        $body = str_replace('${Comment.userid}', $comment->userid, $body);
        $body = str_replace('${link.PluginDetailPage}', 'http://plugins.netbeans.org/plugin/' . $this->publicid, $body);
        $body = str_replace('${link.ProfilePage}', 'http://plugins.netbeans.org/', $body);
        $body = str_replace('\n',"\n",$body);
        $mail = new Zend_Mail();
        $mail->setFrom('webmaster@netbeans.org', 'NetBeans Webmaster');
        $mail->addTo($this->author_userid . '@netbeans.org');
        $mail->setSubject($subject);
        $mail->setBodyText($body);
        $mail->send();
    }





    /**
     * Send email to plugin owner when her plugin us published/pulled off to/from UC
     * @param int $status
     */
    public function sendNotificationOnUcChaneToPluginOwner($status, $version) {
        if ($status == 1) {
            $msg = 'Your plugin ' . $this->plugin_name . ' has been just published for the netbeans ' . $version . ' Update Center';
        } else {
            $msg = 'Your plugin ' . $this->plugin_name . ' has been just pulled from the netbeans ' . $version . ' Update Center';
        }
        $body = "This is an automatic email.  DO NOT REPLY to this email.\n\n" . $msg;
        $body = str_replace('\n',"\n",$body);
        $mail = new Zend_Mail();
        $mail->setFrom('webmaster@netbeans.org', 'NetBeans Webmaster');
        $mail->addTo($this->author_userid . '@netbeans.org');
        $mail->setSubject($msg);
        $mail->setBodyText($body);
        $mail->send();
    }

    private function logme($msg) {
        $this->log[] = $msg;
    }

}